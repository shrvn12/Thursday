<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Room Chat - Conversation</title>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      background: #f1f5f9;
    }

    /* HEADER */
    .header {
      background: #0d6efd;
      color: white;
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .room-info {
      font-size: 13px;
      opacity: 0.9;
    }
    .room-number {
      font-weight: bold;
      font-size: 16px;
      font-family: monospace;
    }
    .header-right {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .status-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
      background: rgba(255,255,255,0.15);
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 13px;
    }
    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }
    .status-online { background: #4ade80; }
    .status-away { background: #fbbf24; }
    .status-offline { background: #ef4444; }
    .status-disconnected { background: #6b7280; }

    .leave-btn {
      background: #dc3545;
      color: white;
      border: none;
      padding: 8px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      transition: background 0.2s;
    }
    .leave-btn:hover {
      background: #bb2d3b;
    }

    /* CHAT LAYOUT */
    #chat {
      display: flex;
      flex: 1;
      gap: 20px;
      padding: 20px;
      box-sizing: border-box;
    }
    #me, #other, #myPreview, #otherRaw {
      flex: 1;
      font-size: 15px;
      white-space: pre-wrap;
      line-height: 1.6;
      overflow-y: auto;
    }

    /* PANEL STYLING */
    .panel {
      flex: 1;
      background: #fff;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
      overflow: hidden;
    }
    .panel-header {
      padding: 14px 18px 0 18px;
    }
    .panel-label {
      font-size: 12px;
      text-transform: uppercase;
      font-weight: 700;
      color: #111827;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .panel-controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .preview-btn {
      border: none;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
      background: #e5e7eb;
      color: #111827;
      font-weight: 500;
      transition: background 0.2s;
    }
    .preview-btn:hover {
      background: #d1d5db;
    }
    .preview-btn.active {
      background: #0d6efd;
      color: white;
    }
    .char-count {
      font-size: 11px;
      color: #6b7280;
    }

    /* CONTENT */
    #me {
      padding: 16px 18px;
      outline: none;
    }
    #myPreview {
      padding: 16px 18px;
      display: none;
    }
    #other {
      padding: 16px 18px;
    }
    #otherRaw {
      padding: 16px 18px;
      font-family: monospace;
      display: none;
      background: #f9fafb;
    }

    /* MARKDOWN STYLING */
    .markdown-content h1 {
      font-size: 20px;
      font-weight: 700;
      margin: 12px 0 8px;
      border-bottom: 2px solid #e2e8f0;
      padding-bottom: 4px;
    }
    .markdown-content h2 {
      font-size: 18px;
      font-weight: 600;
      margin: 10px 0 6px;
    }
    .markdown-content p {
      margin: 6px 0;
    }
    .markdown-content ul, .markdown-content ol {
      margin: 6px 0;
      padding-left: 20px;
    }
    .markdown-content li {
      margin: 2px 0;
    }
    .markdown-content strong {
      font-weight: 700;
    }
    .markdown-content em {
      font-style: italic;
    }
    .markdown-content code {
      background: #f3f4f6;
      padding: 2px 4px;
      border-radius: 3px;
      font-family: monospace;
    }
    .markdown-content pre {
      background: #1e293b;
      color: #f9fafb;
      padding: 12px;
      border-radius: 6px;
      overflow-x: auto;
    }

    /* EMOJI FLOAT */
    .emoji-float {
      position: fixed;
      font-size: 32px;
      pointer-events: none;
      z-index: 1000;
      animation: floatUp 3s ease-out forwards;
    }
    @keyframes floatUp {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-200px); opacity: 0; }
    }
    .floating-emoji-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: #0d6efd;
      color: white;
      border: none;
      font-size: 22px;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .emoji-picker {
      position: fixed;
      bottom: 80px;
      right: 20px;
      background: white;
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      display: none;
    }
    .emoji-picker.show {
      display: block;
    }
    .emoji-btn {
      font-size: 22px;
      border: none;
      background: none;
      cursor: pointer;
      margin: 4px;
    }
  </style>
</head>
<body>
  <div class="header">
    <div>
      <div class="room-info">Room ID</div>
      <div class="room-number" id="roomDisplay"></div>
    </div>
    <div class="header-right">
      <div class="status-indicator">
        <div class="status-dot" id="statusDot"></div>
        <span id="statusText">Connecting...</span>
      </div>
      <button class="leave-btn" onclick="leaveRoom()">Leave Room</button>
    </div>
  </div>

  <div id="chat">
    <!-- Left Panel -->
    <div class="panel">
      <div class="panel-header">
        <div class="panel-label">
          <span>YOU (MARKDOWN SUPPORTED)</span>
          <div class="panel-controls">
            <button class="preview-btn" id="previewBtn" onclick="togglePreview()">üëÅÔ∏è Preview</button>
            <span class="char-count" id="myCharCount">0 CHARACTERS</span>
          </div>
        </div>
      </div>
      <div id="me" contenteditable="true"></div>
      <div id="myPreview"></div>
    </div>

    <!-- Right Panel -->
    <div class="panel">
      <div class="panel-header">
        <div class="panel-label">
          <span>PARTICIPANT</span>
          <div class="panel-controls">
            <button class="preview-btn" id="rawViewBtn" onclick="toggleRawView()">üìÑ Raw</button>
            <span class="char-count" id="otherCharCount">0 CHARACTERS</span>
          </div>
        </div>
      </div>
      <div id="other"></div>
      <div id="otherRaw"></div>
    </div>
  </div>

  <!-- Emoji -->
  <button class="floating-emoji-toggle" onclick="toggleEmojiPicker()">üòä</button>
  <div class="emoji-picker" id="emojiPicker">
    <button class="emoji-btn" onclick="sendEmoji('‚ù§Ô∏è')">‚ù§Ô∏è</button>
    <button class="emoji-btn" onclick="sendEmoji('üëç')">üëç</button>
    <button class="emoji-btn" onclick="sendEmoji('üòÇ')">üòÇ</button>
    <button class="emoji-btn" onclick="sendEmoji('üéâ')">üéâ</button>
    <button class="emoji-btn" onclick="sendEmoji('üî•')">üî•</button>
    <button class="emoji-btn" onclick="sendEmoji('üëè')">üëè</button>
  </div>

  <!-- Your original scripts preserved -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.5/dist/purify.min.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    /* JS code same as your original file (left unchanged for functionality) */
    // ... paste your existing JavaScript here from old chat.html ...
  </script>
</body>
</html>


<script>

  function scrollToBottom(el) {
    el.scrollTop = el.scrollHeight;
  }

  const urlParams = new URLSearchParams(window.location.search);
  const currentRoom = urlParams.get("room");
  const clientId = urlParams.get("client") || crypto.randomUUID();

  if (!currentRoom) {
    window.location.href = "index.html";
  }

  document.getElementById("roomDisplay").textContent = currentRoom;
  
  // Initialize Socket.IO connection
  const socket = io();
  let isConnected = false;
 
  let lastActivity = Date.now();
  let otherUserStatus = 'offline';
  let emojiCounter = 0; // For varied animations
  let lastEmojiSent = 0; // Throttling for emoji sending
  let isPreviewMode = false; // Track preview mode state
  let isRawViewMode = false; // Track raw view mode state
  let otherPersonRawText = ''; // Store the raw text from other person

  // Update status based on page visibility and activity
  function updateMyStatus() {
    const isActive = document.visibilityState === 'visible';
    const isIdle = Date.now() - lastActivity > 30000; // 30 seconds idle
    
    let status = 'online';
    if (!isActive) status = 'away';
    if (isIdle && isActive) status = 'away';
    
    return status;
  }

  function updateStatusDisplay() {
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    
    statusDot.className = 'status-dot status-' + otherUserStatus;
    
    const statusMessages = {
      'online': 'Online',
      'away': 'Away',
      'offline': 'Offline',
      'disconnected': 'Disconnected'
    };
    
    statusText.textContent = statusMessages[otherUserStatus] || 'Connecting...';
  }

  function updateCharCount() {
    const myElement = document.getElementById("me");
    
    const myText = myElement.innerText || myElement.textContent || '';
    // Use raw text for other person's character count for consistency
    const otherText = otherPersonRawText || '';
    
    document.getElementById("myCharCount").textContent = myText.length + ' characters';
    document.getElementById("otherCharCount").textContent = otherText.length + ' characters';
  }
  
  // Markdown rendering function with sanitization
  function renderMarkdown(text) {
    if (!text || typeof text !== 'string') return '';
    
    try {
      // Configure marked with safe options
      marked.setOptions({
        breaks: true,
        gfm: true,
        sanitize: false // We'll use DOMPurify instead
      });
      
      const html = marked.parse(text);
      
      // Sanitize the HTML to prevent XSS
      return DOMPurify.sanitize(html, {
        ALLOWED_TAGS: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'br', 'strong', 'em', 'u', 's', 'code', 'pre', 'blockquote', 'ul', 'ol', 'li', 'a', 'hr', 'table', 'thead', 'tbody', 'tr', 'th', 'td'],
        ALLOWED_ATTR: ['href', 'title', 'target']
      });
    } catch (err) {
      console.error('Error rendering markdown:', err);
      return text; // Return original text if rendering fails
    }
  }
  
  // Toggle between edit and preview mode
  function togglePreview() {
    const meElement = document.getElementById('me');
    const previewElement = document.getElementById('myPreview');
    const previewBtn = document.getElementById('previewBtn');
    
    isPreviewMode = !isPreviewMode;
    
    if (isPreviewMode) {
      // Switch to preview mode
      const text = meElement.innerText;
      previewElement.innerHTML = '<div class="markdown-content">' + renderMarkdown(text) + '</div>';
      
      meElement.style.display = 'none';
      previewElement.style.display = 'block';
      
      previewBtn.textContent = '‚úèÔ∏è Edit';
      previewBtn.classList.add('active');
      previewBtn.title = 'Switch to Edit Mode';
    } else {
      // Switch to edit mode
      meElement.style.display = 'block';
      previewElement.style.display = 'none';
      
      previewBtn.textContent = 'üëÅÔ∏è Preview';
      previewBtn.classList.remove('active');
      previewBtn.title = 'Toggle Markdown Preview';
      
      // Focus back to editor
      meElement.focus();
    }
  }
  
  // Toggle between rendered and raw view for other person's content
  function toggleRawView() {
    const otherElement = document.getElementById('other');
    const otherRawElement = document.getElementById('otherRaw');
    const rawViewBtn = document.getElementById('rawViewBtn');
    
    isRawViewMode = !isRawViewMode;
    
    if (isRawViewMode) {
      // Switch to raw view mode
      otherRawElement.textContent = otherPersonRawText;
      
      otherElement.style.display = 'none';
      otherRawElement.style.display = 'block';
      
      rawViewBtn.textContent = 'üé® Rendered';
      rawViewBtn.classList.add('active');
      rawViewBtn.title = 'Switch to Rendered View';
    } else {
      // Switch to rendered view mode
      otherElement.style.display = 'block';
      otherRawElement.style.display = 'none';
      
      rawViewBtn.textContent = 'üìÑ Raw';
      rawViewBtn.classList.remove('active');
      rawViewBtn.title = 'Toggle Raw Markdown View';
    }
  }

  function leaveRoom() {
    if (isConnected) {
      socket.emit('disconnect-user');
      socket.disconnect();
    }
    window.location.href = "index.html";
  }

  function toggleEmojiPicker() {
    document.getElementById('emojiPicker').classList.toggle('show');
  }

  function sendEmoji(emoji) {
    const now = Date.now();
    
    // Throttle emoji sending to prevent spam (max 1 per 500ms)
    if (now - lastEmojiSent < 500) {
      console.log('Emoji sending throttled');
      return;
    }
    
    lastEmojiSent = now;
    
    // Show immediate local feedback
    createFloatingEmoji(emoji);
    
    // Send to server via Socket.IO
    if (isConnected) {
      socket.emit('send-emoji', { emoji });
    }
    
    toggleEmojiPicker();
  }

  function createFloatingEmoji(emoji) {
    try {
      // Create the element
      const emojiEl = document.createElement('div');
      emojiEl.className = 'emoji-float';
      emojiEl.textContent = emoji;
      emojiEl.dataset.created = Date.now().toString();
      
      // Increment counter for animation variation
      emojiCounter++;
      
      // Get chat container dimensions for better positioning
      const chatContainer = document.getElementById('chat');
      if (!chatContainer) {
        console.warn('Chat container not found, using fallback positioning');
        // Fallback positioning
        emojiEl.style.left = `${Math.random() * (window.innerWidth - 100)}px`;
        emojiEl.style.top = `${window.innerHeight - 100}px`;
      } else {
        const chatRect = chatContainer.getBoundingClientRect();
        
        // Calculate a position that's always within the visible chat area
        const padding = 60; // Space from edges
        const minX = Math.max(chatRect.left + padding, 50);
        const maxX = Math.min(chatRect.right - padding, window.innerWidth - 50);
        const posX = minX + Math.random() * Math.max(maxX - minX, 100);
        
        // Position at the bottom of the chat area with some variation
        const baseY = Math.max(chatRect.bottom - 120, window.innerHeight - 150);
        const posY = baseY + (Math.random() * 40 - 20); // ¬±20px variation
        
        emojiEl.style.left = `${posX}px`;
        emojiEl.style.top = `${posY}px`;
      }
      
      // Add some random timing variation to prevent all emojis from moving identically
      const animationDelay = Math.random() * 200; // 0-200ms delay
      emojiEl.style.animationDelay = `${animationDelay}ms`;
      
      // Add slight size variation
      const sizeVariation = 0.8 + Math.random() * 0.4; // 0.8x to 1.2x size
      emojiEl.style.fontSize = `${32 * sizeVariation}px`;
      
      // Add to DOM
      document.body.appendChild(emojiEl);
      
      // Enhanced cleanup with multiple fallbacks
      const cleanup = () => {
        try {
          if (emojiEl && emojiEl.parentNode) {
            emojiEl.parentNode.removeChild(emojiEl);
          }
        } catch (err) {
          console.error('Error removing emoji element:', err);
        }
      };
      
      // Primary cleanup after animation
      setTimeout(cleanup, 3200);
      
      // Fallback cleanup in case the first one fails
      setTimeout(cleanup, 5000);
      
      // Cleanup on animation end event
      emojiEl.addEventListener('animationend', cleanup, { once: true });
      
    } catch (err) {
      console.error('Error creating floating emoji:', err);
    }
  }


  // Socket.IO event handlers
  socket.on('connect', () => {
    console.log('Connected to server');
    isConnected = true;
    
    // Join the room
    socket.emit('join-room', {
      room: currentRoom,
      client: clientId
    });
  });
  
  socket.on('disconnect', () => {
    console.log('Disconnected from server');
    isConnected = false;
    otherUserStatus = 'offline';
    updateStatusDisplay();
  });
  
  socket.on('room-full', (data) => {
    alert("Room is full! You have been disconnected.");
    window.location.href = "index.html";
  });
  
  socket.on('room-state', (data) => {
    // Receive initial room state when joining
    if (data.text !== undefined) {
      updateOtherPersonText(data.text);
    }
  });
  
  socket.on('message-received', (data) => {
    if (data.text !== undefined) {
      updateOtherPersonText(data.text);
    }
  });
  
  socket.on('user-status', (data) => {
    otherUserStatus = data.status;
    updateStatusDisplay();
  });
  
  socket.on('user-left', (data) => {
    console.log(`User left room. Remaining users: ${data.remainingUsers}`);
    
    otherUserStatus = 'disconnected';
    updateStatusDisplay();
    
    // If no other users remain, redirect to landing page
    if (data.remainingUsers === 0) {
      alert("The other user has left the room. Returning to main page.");
      socket.disconnect();
      window.location.href = "index.html";
    }
  });
  
  socket.on('emoji-received', (data) => {
    createFloatingEmoji(data.emoji);
  });
  
  socket.on('error', (data) => {
    console.error('Socket error:', data.message);
  });
  
  // Helper function to update other person's text
  function updateOtherPersonText(text) {

    const otherElement = document.getElementById("other");
    const otherRawElement = document.getElementById("otherRaw");
    scrollToBottom(otherElement);
    // Store the raw text
    otherPersonRawText = text || "";
    
    // Update rendered view
    if (text && text.trim()) {
      otherElement.innerHTML = '<div class="markdown-content">' + renderMarkdown(text) + '</div>';
    } else {
      otherElement.textContent = text || "";
    }
    
    // Update raw view if it's currently visible
    if (isRawViewMode) {
      otherRawElement.textContent = text || "";
      scrollToBottom(otherRawElement);
    }
    
    updateCharCount();
  }

  function sendUpdate() {
    if (!isConnected) {
      return;
    }
    
    const text = document.getElementById("me").innerText;
    const status = updateMyStatus();
    
    // Send message via Socket.IO
    socket.emit('send-message', {
      text: text,
      status: status
    });
    
    lastActivity = Date.now();
    updateCharCount();
  }

  // Track activity
  document.addEventListener('mousemove', () => lastActivity = Date.now());
  document.addEventListener('keypress', () => lastActivity = Date.now());
  document.addEventListener('visibilitychange', sendUpdate);
  
  // Handle tab close/page navigation
  window.addEventListener('beforeunload', () => {
    if (isConnected) {
      socket.emit('disconnect-user');
      socket.disconnect();
    }
  });
  
  // Handle page visibility changes for better disconnect detection
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'hidden') {
      // User switched tabs or minimized - mark as away
      sendUpdate();
    } else {
      // User returned - mark as active
      lastActivity = Date.now();
      sendUpdate();
    }
  });

  document.getElementById("me").addEventListener("input", sendUpdate);
  document.getElementById("me").addEventListener("keyup", sendUpdate);

  // Send heartbeat every 5 seconds
  setInterval(() => {
    if (isConnected) {
      const status = updateMyStatus();
      socket.emit('heartbeat', { status });
      lastActivity = Date.now();
    }
  }, 5000);
  
  // Cleanup orphaned emoji elements every 10 seconds
  setInterval(() => {
    try {
      const orphanedEmojis = document.querySelectorAll('.emoji-float');
      orphanedEmojis.forEach(emoji => {
        // Remove emojis that have been around for more than 6 seconds
        const creationTime = emoji.dataset.created;
        if (creationTime && Date.now() - parseInt(creationTime) > 6000) {
          emoji.remove();
        }
      });
    } catch (err) {
      console.error('Error in emoji cleanup:', err);
    }
  }, 10000);

  // Check for auto-join from URL parameter
  const autoJoin = urlParams.get("join");
  if (autoJoin && !currentRoom) {
    window.location.href = `chat.html?room=${autoJoin}&client=${clientId}`;
  }

  // Initialize character count
  updateCharCount();
</script>